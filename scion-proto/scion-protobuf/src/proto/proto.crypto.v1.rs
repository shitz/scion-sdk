// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    /// Encoded header and body.
    #[prost(bytes = "vec", tag = "1")]
    pub header_and_body: ::prost::alloc::vec::Vec<u8>,
    /// Raw signature. The signature is computed over the concatenation of the
    /// header and body, and the optional associated data.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    /// Algorithm used to compute the signature.
    #[prost(enumeration = "SignatureAlgorithm", tag = "1")]
    pub signature_algorithm: i32,
    /// Optional arbitrary per-protocol key identifier.
    #[prost(bytes = "vec", tag = "2")]
    pub verification_key_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional signature creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional arbitrary per-protocol metadata.
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    /// Length of associated data that is covered by the signature, but is not
    /// included in the header and body. This is zero, if no associated data is
    /// covered by the signature.
    #[prost(int32, tag = "5")]
    pub associated_data_length: i32,
}
/// Low-level representation of HeaderAndBody used for signature computation
/// input. This should not be used by external code.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeaderAndBodyInternal {
    /// Enocded header suitable for signature computation.
    #[prost(bytes = "vec", tag = "1")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// Raw payload suitable for signature computation.
    #[prost(bytes = "vec", tag = "2")]
    pub body: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureAlgorithm {
    /// Unspecified signature algorithm. This value is never valid.
    Unspecified = 0,
    /// ECDS with SHA256.
    EcdsaWithSha256 = 1,
    /// ECDS with SHA384.
    EcdsaWithSha384 = 2,
    /// ECDS with SHA512.
    EcdsaWithSha512 = 3,
}
impl SignatureAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNATURE_ALGORITHM_UNSPECIFIED",
            Self::EcdsaWithSha256 => "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA256",
            Self::EcdsaWithSha384 => "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA384",
            Self::EcdsaWithSha512 => "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA512",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA256" => Some(Self::EcdsaWithSha256),
            "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA384" => Some(Self::EcdsaWithSha384),
            "SIGNATURE_ALGORITHM_ECDSA_WITH_SHA512" => Some(Self::EcdsaWithSha512),
            _ => None,
        }
    }
}
